% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gregorian-year-month-day.R
\name{parse_year_month_day}
\alias{parse_year_month_day}
\title{Parse into a year-month-day calendar}
\usage{
parse_year_month_day(x, ..., precision = "day")
}
\arguments{
\item{x}{\verb{[character]}

A character vector to parse.}

\item{...}{These dots are for future extensions and must be empty.}

\item{precision}{\verb{[character(1)]}

The precision of the resulting year-month-day.}
}
\value{
A year-month-day calendar vector. If a parsing fails, \code{NA} is
returned.
}
\description{
\code{parse_year_month_day()} parses a character vector into a year-month-day
calendar.
}
\details{
There is no \code{format} argument, as this function can only parse the result
of \code{\link[=format]{format()}}-ting a year-month-day. If you need the flexibility of a
\code{format} argument, try \code{\link[=parse_naive_time]{parse_naive_time()}} or \code{\link[=parse_sys_time]{parse_sys_time()}}.
}
\examples{
x <- "2019-01-01"

# Default parses at day precision
parse_year_month_day(x)

# Can parse at less precise precisions too
parse_year_month_day(x, precision = "month")
parse_year_month_day(x, precision = "year")

# Even invalid dates can be round-tripped through format<->parse calls
invalid <- year_month_day(2019, 2, 30)
parse_year_month_day(format(invalid))

# Can parse with time of day
x <- year_month_day(
  2019, 01, 30, 02, 30, 00, 5000,
  subsecond_precision = "nanosecond"
)

parse_year_month_day(format(x), precision = "nanosecond")
}
