% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/weekday.R
\name{weekday}
\alias{weekday}
\title{Construct a weekday vector}
\usage{
weekday(day = integer())
}
\arguments{
\item{day}{\verb{[integer]}

The values for \code{day} can be provided as:
\itemize{
\item Integers between \verb{[0, 6]}, with 0 = Sunday and 6 = Saturday. This is
known as \emph{C encoding}.
\item Integers between \verb{[1, 7]}, with 1 = Monday and 7 = Sunday. This is
known as \emph{ISO encoding}.
}

Because the only value that differs in the two encodings is Sunday (it
is a 0 in C encoding, but a 7 in ISO encoding), you can supply either
encoding as \code{day}, as long as you don't mix 0's with 7's.}
}
\value{
A weekday vector.
}
\description{
A \code{weekday} is a simple type that represents a day of the week.

The most interesting thing about the weekday type is that it implements
\emph{circular arithmetic}, which makes determining the "next Monday" or
"previous Tuesday" from a sys-time or naive-time easy to compute.
See the examples.
}
\examples{
x <- as_naive(year_month_day(2019, 01, 05))

# This is a Saturday!
as_weekday(x)

# Adjust to the next Wednesday
wednesday <- weekday(3)

# This returns the number of days until the next Wednesday using
# circular arithmetic
# "Wednesday - Saturday = 4 days until next Wednesday"
wednesday - as_weekday(x)

# Advance to the next Wednesday
x_next_wednesday <- x + (wednesday - as_weekday(x))

as_weekday(x_next_wednesday)

# What about the previous Tuesday?
tuesday <- weekday(2)
x - (as_weekday(x) - tuesday)

# What about the next Saturday?
# With an additional condition that if today is a Saturday,
# then advance to the next one.
saturday <- weekday(6)
x + 1L + (saturday - as_weekday(x + 1L))
}
