% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/duration.R
\name{duration-rounding}
\alias{duration-rounding}
\alias{duration_floor}
\alias{duration_ceiling}
\alias{duration_round}
\title{Duration rounding}
\usage{
duration_floor(x, precision, ..., n = 1L)

duration_ceiling(x, precision, ..., n = 1L)

duration_round(x, precision, ..., n = 1L)
}
\arguments{
\item{x}{\verb{[clock_duration]}

A duration.}

\item{precision}{\verb{[character(1)]}

A precision. One of:
\itemize{
\item \code{"year"}
\item \code{"quarter"}
\item \code{"month"}
\item \code{"week"}
\item \code{"day"}
\item \code{"hour"}
\item \code{"minute"}
\item \code{"second"}
\item \code{"millisecond"}
\item \code{"microsecond"}
\item \code{"nanosecond"}
}}

\item{...}{These dots are for future extensions and must be empty.}

\item{n}{\verb{[positive integer(1)]}

A positive integer specifying the multiple of \code{precision} to use.}
}
\description{
\itemize{
\item \code{duration_floor()} rounds a duration down to a multiple of the specified
\code{precision}.
\item \code{duration_ceiling()} rounds a duration up to a multiple of the specified
\code{precision}.
\item \code{duration_round()} rounds up or down depending on what is closer,
rounding up on ties.
}
}
\details{
Duration rounding is most useful when rounding from sub-daily precisions up
to daily precision, or when rounding monthly/quarterly precisions up to
yearly precision. These durations are defined intuitively relative to
each other.

Be \emph{extremely} careful when rounding sub-daily or daily precisions up to more
granular precisions such as monthly or yearly. Durations are defined in terms
of a number of seconds, and calendrical months and years cannot be broken
down like that, since they are irregular periods of time (there aren't always
30 days in a month, or 365 days in a year). Read the Internal Representation
section of the documentation for \link[=duration-helper]{duration helpers} to
learn more about how durations are defined.
}
\examples{
x <- duration_seconds(c(86399, 86401))

duration_floor(x, "day")
duration_ceiling(x, "day")

# Every 2 days, using an origin of day 0
y <- duration_seconds(c(0, 86400, 86400 * 2, 86400 * 3))
duration_floor(y, "day", n = 2)

# Shifting the origin to be day 1
origin <- duration_days(1)
duration_floor(y - origin, "day", n = 2) + origin

# Rounding will round ties up
half_day <- 86400 / 2
half_day_durations <- duration_seconds(c(half_day - 1, half_day, half_day + 1))
duration_round(half_day_durations, "day")
}
