% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gregorian-year-month-day.R
\name{year_month_day}
\alias{year_month_day}
\title{Calendar: year-month-day}
\usage{
year_month_day(
  year,
  month = NULL,
  day = NULL,
  hour = NULL,
  minute = NULL,
  second = NULL,
  subsecond = NULL,
  ...,
  subsecond_precision = NULL
)
}
\arguments{
\item{year}{\verb{[integer]}

The year.}

\item{month}{\verb{[integer / NULL]}

The month.}

\item{day}{\verb{[integer / NULL]}

The day.}

\item{hour}{\verb{[integer / NULL]}

The hour.}

\item{minute}{\verb{[integer / NULL]}

The minute.}

\item{second}{\verb{[integer / NULL]}

The second.}

\item{subsecond}{\verb{[integer / NULL]}

The subsecond. If specified, \code{subsecond_precision} must also be specified
to determine how to interpret the \code{subsecond}.}

\item{subsecond_precision}{\verb{[character(1) / NULL]}

The precision to interpret \code{subsecond} as. One of: \code{"millisecond"},
\code{"microsecond"}, or \code{"nanosecond"}.}
}
\value{
A year-month-day calendar object.
}
\description{
\code{year_month_day()} constructs the most common calendar type using the
Gregorian year, month, day, and time of day components.
}
\details{
Fields are recycled against each other.

Fields are collected in order until the first \code{NULL} field is located. No
fields after the first \code{NULL} field are used.
}
\examples{
# Just the year
x <- year_month_day(2019:2025)

# Year-month type
year_month_day(2020, 1:12)

# The most common use case involves year, month, and day fields
x <- year_month_day(2020, 1, 1:5)
x

# Precision can go all the way out to nanosecond
year_month_day(2019, 1, 2, 2, 40, 45, 200, subsecond_precision = "nanosecond")
}
