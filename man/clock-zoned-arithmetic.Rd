% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/arithmetic.R
\name{clock-zoned-arithmetic}
\alias{clock-zoned-arithmetic}
\alias{add_years.Date}
\alias{add_years.POSIXt}
\alias{add_years.clock_zoned_time_point}
\alias{add_years.clock_naive_time_point}
\alias{add_years.clock_calendar}
\alias{subtract_years.Date}
\alias{subtract_years.POSIXt}
\alias{subtract_years.clock_zoned_time_point}
\alias{add_quarters.Date}
\alias{add_quarters.POSIXt}
\alias{add_quarters.clock_zoned_time_point}
\alias{add_quarters.clock_naive_time_point}
\alias{add_quarters.clock_calendar}
\alias{subtract_quarters.Date}
\alias{subtract_quarters.POSIXt}
\alias{subtract_quarters.clock_zoned_time_point}
\alias{add_months.Date}
\alias{add_months.POSIXt}
\alias{add_months.clock_zoned_time_point}
\alias{add_months.clock_naive_time_point}
\alias{add_months.clock_calendar}
\alias{subtract_months.Date}
\alias{subtract_months.POSIXt}
\alias{subtract_months.clock_zoned_time_point}
\alias{add_weeks.Date}
\alias{add_weeks.POSIXt}
\alias{add_weeks.clock_zoned_time_point}
\alias{add_weeks.clock_naive_time_point}
\alias{add_weeks.clock_calendar}
\alias{subtract_weeks.Date}
\alias{subtract_weeks.POSIXt}
\alias{subtract_weeks.clock_zoned_time_point}
\alias{add_days.Date}
\alias{add_days.POSIXt}
\alias{add_days.clock_zoned_time_point}
\alias{add_days.clock_naive_time_point}
\alias{add_days.clock_calendar}
\alias{subtract_days.Date}
\alias{subtract_days.POSIXt}
\alias{subtract_days.clock_zoned_time_point}
\alias{add_hours.Date}
\alias{add_hours.POSIXt}
\alias{add_hours.clock_zoned_time_point}
\alias{subtract_hours.Date}
\alias{subtract_hours.POSIXt}
\alias{subtract_hours.clock_zoned_time_point}
\alias{add_minutes.Date}
\alias{add_minutes.POSIXt}
\alias{add_minutes.clock_zoned_time_point}
\alias{subtract_minutes.Date}
\alias{subtract_minutes.POSIXt}
\alias{subtract_minutes.clock_zoned_time_point}
\alias{add_seconds.Date}
\alias{add_seconds.POSIXt}
\alias{add_seconds.clock_zoned_time_point}
\alias{subtract_seconds.Date}
\alias{subtract_seconds.POSIXt}
\alias{subtract_seconds.clock_zoned_time_point}
\alias{add_milliseconds.Date}
\alias{add_milliseconds.POSIXt}
\alias{add_milliseconds.clock_zoned_time_point}
\alias{subtract_milliseconds.Date}
\alias{subtract_milliseconds.POSIXt}
\alias{subtract_milliseconds.clock_zoned_time_point}
\alias{add_microseconds.Date}
\alias{add_microseconds.POSIXt}
\alias{add_microseconds.clock_zoned_time_point}
\alias{subtract_microseconds.Date}
\alias{subtract_microseconds.POSIXt}
\alias{subtract_microseconds.clock_zoned_time_point}
\alias{add_nanoseconds.Date}
\alias{add_nanoseconds.POSIXt}
\alias{add_nanoseconds.clock_zoned_time_point}
\alias{subtract_nanoseconds.Date}
\alias{subtract_nanoseconds.POSIXt}
\alias{subtract_nanoseconds.clock_zoned_time_point}
\title{Zoned date-time arithmetic}
\usage{
\method{add_years}{Date}(x, n, ..., day_nonexistent = "last-time")

\method{add_years}{POSIXt}(
  x,
  n,
  ...,
  day_nonexistent = "last-time",
  dst_nonexistent = NULL,
  dst_ambiguous = NULL
)

\method{add_years}{clock_zoned_time_point}(
  x,
  n,
  ...,
  day_nonexistent = "last-time",
  dst_nonexistent = NULL,
  dst_ambiguous = NULL
)

\method{add_years}{clock_naive_time_point}(x, n, ..., day_nonexistent = "last-time")

\method{add_years}{clock_calendar}(x, n, ..., day_nonexistent = "last-time")

\method{subtract_years}{Date}(x, n, ..., day_nonexistent = "last-time")

\method{subtract_years}{POSIXt}(
  x,
  n,
  ...,
  day_nonexistent = "last-time",
  dst_nonexistent = NULL,
  dst_ambiguous = NULL
)

\method{subtract_years}{clock_zoned_time_point}(
  x,
  n,
  ...,
  day_nonexistent = "last-time",
  dst_nonexistent = NULL,
  dst_ambiguous = NULL
)

\method{add_quarters}{Date}(x, n, ..., day_nonexistent = "last-time")

\method{add_quarters}{POSIXt}(
  x,
  n,
  ...,
  day_nonexistent = "last-time",
  dst_nonexistent = NULL,
  dst_ambiguous = NULL
)

\method{add_quarters}{clock_zoned_time_point}(
  x,
  n,
  ...,
  day_nonexistent = "last-time",
  dst_nonexistent = NULL,
  dst_ambiguous = NULL
)

\method{add_quarters}{clock_naive_time_point}(x, n, ..., day_nonexistent = "last-time")

\method{add_quarters}{clock_calendar}(x, n, ..., day_nonexistent = "last-time")

\method{subtract_quarters}{Date}(x, n, ..., day_nonexistent = "last-time")

\method{subtract_quarters}{POSIXt}(
  x,
  n,
  ...,
  day_nonexistent = "last-time",
  dst_nonexistent = NULL,
  dst_ambiguous = NULL
)

\method{subtract_quarters}{clock_zoned_time_point}(
  x,
  n,
  ...,
  day_nonexistent = "last-time",
  dst_nonexistent = NULL,
  dst_ambiguous = NULL
)

\method{add_months}{Date}(x, n, ..., day_nonexistent = "last-time")

\method{add_months}{POSIXt}(
  x,
  n,
  ...,
  day_nonexistent = "last-time",
  dst_nonexistent = NULL,
  dst_ambiguous = NULL
)

\method{add_months}{clock_zoned_time_point}(
  x,
  n,
  ...,
  day_nonexistent = "last-time",
  dst_nonexistent = NULL,
  dst_ambiguous = NULL
)

\method{add_months}{clock_naive_time_point}(x, n, ..., day_nonexistent = "last-time")

\method{add_months}{clock_calendar}(x, n, ..., day_nonexistent = "last-time")

\method{subtract_months}{Date}(x, n, ..., day_nonexistent = "last-time")

\method{subtract_months}{POSIXt}(
  x,
  n,
  ...,
  day_nonexistent = "last-time",
  dst_nonexistent = NULL,
  dst_ambiguous = NULL
)

\method{subtract_months}{clock_zoned_time_point}(
  x,
  n,
  ...,
  day_nonexistent = "last-time",
  dst_nonexistent = NULL,
  dst_ambiguous = NULL
)

\method{add_weeks}{Date}(x, n, ...)

\method{add_weeks}{POSIXt}(x, n, ..., dst_nonexistent = NULL, dst_ambiguous = NULL)

\method{add_weeks}{clock_zoned_time_point}(x, n, ..., dst_nonexistent = NULL, dst_ambiguous = NULL)

\method{add_weeks}{clock_naive_time_point}(x, n, ...)

\method{add_weeks}{clock_calendar}(x, n, ...)

\method{subtract_weeks}{Date}(x, n, ...)

\method{subtract_weeks}{POSIXt}(x, n, ..., dst_nonexistent = NULL, dst_ambiguous = NULL)

\method{subtract_weeks}{clock_zoned_time_point}(x, n, ..., dst_nonexistent = NULL, dst_ambiguous = NULL)

\method{add_days}{Date}(x, n, ...)

\method{add_days}{POSIXt}(x, n, ..., dst_nonexistent = NULL, dst_ambiguous = NULL)

\method{add_days}{clock_zoned_time_point}(x, n, ..., dst_nonexistent = NULL, dst_ambiguous = NULL)

\method{add_days}{clock_naive_time_point}(x, n, ...)

\method{add_days}{clock_calendar}(x, n, ...)

\method{subtract_days}{Date}(x, n, ...)

\method{subtract_days}{POSIXt}(x, n, ..., dst_nonexistent = NULL, dst_ambiguous = NULL)

\method{subtract_days}{clock_zoned_time_point}(x, n, ..., dst_nonexistent = NULL, dst_ambiguous = NULL)

\method{add_hours}{Date}(x, n, ...)

\method{add_hours}{POSIXt}(x, n, ...)

\method{add_hours}{clock_zoned_time_point}(x, n, ...)

\method{subtract_hours}{Date}(x, n, ...)

\method{subtract_hours}{POSIXt}(x, n, ...)

\method{subtract_hours}{clock_zoned_time_point}(x, n, ...)

\method{add_minutes}{Date}(x, n, ...)

\method{add_minutes}{POSIXt}(x, n, ...)

\method{add_minutes}{clock_zoned_time_point}(x, n, ...)

\method{subtract_minutes}{Date}(x, n, ...)

\method{subtract_minutes}{POSIXt}(x, n, ...)

\method{subtract_minutes}{clock_zoned_time_point}(x, n, ...)

\method{add_seconds}{Date}(x, n, ...)

\method{add_seconds}{POSIXt}(x, n, ...)

\method{add_seconds}{clock_zoned_time_point}(x, n, ...)

\method{subtract_seconds}{Date}(x, n, ...)

\method{subtract_seconds}{POSIXt}(x, n, ...)

\method{subtract_seconds}{clock_zoned_time_point}(x, n, ...)

\method{add_milliseconds}{Date}(x, n, ...)

\method{add_milliseconds}{POSIXt}(x, n, ...)

\method{add_milliseconds}{clock_zoned_time_point}(x, n, ...)

\method{subtract_milliseconds}{Date}(x, n, ...)

\method{subtract_milliseconds}{POSIXt}(x, n, ...)

\method{subtract_milliseconds}{clock_zoned_time_point}(x, n, ...)

\method{add_microseconds}{Date}(x, n, ...)

\method{add_microseconds}{POSIXt}(x, n, ...)

\method{add_microseconds}{clock_zoned_time_point}(x, n, ...)

\method{subtract_microseconds}{Date}(x, n, ...)

\method{subtract_microseconds}{POSIXt}(x, n, ...)

\method{subtract_microseconds}{clock_zoned_time_point}(x, n, ...)

\method{add_nanoseconds}{Date}(x, n, ...)

\method{add_nanoseconds}{POSIXt}(x, n, ...)

\method{add_nanoseconds}{clock_zoned_time_point}(x, n, ...)

\method{subtract_nanoseconds}{Date}(x, n, ...)

\method{subtract_nanoseconds}{POSIXt}(x, n, ...)

\method{subtract_nanoseconds}{clock_zoned_time_point}(x, n, ...)
}
\arguments{
\item{x}{\verb{[Date / POSIXct / POSIXlt]}

A zoned date-time vector.}

\item{n}{\verb{[integer]}

An integer vector representing the number of units to add to or
subtract from \code{x}.}

\item{...}{These dots are for future extensions and must be empty.}

\item{day_nonexistent}{\verb{[character(1)]}

Control the behavior when a nonexistent day is generated.
\itemize{
\item \code{"last-time"}: Adjust to the last possible time of the current month.
\item \code{"first-time"}: Adjust to the first possible time of the following month.
\item \code{"last-day"}: Adjust to the last day of the current month. For
date-times, the sub-daily components are kept.
\item \code{"first-day"}: Adjust to the first day of the following month. For
date-times, the sub-daily components are kept.
\item \code{"NA"}: Replace the nonexistent date with \code{NA}.
\item \code{"error"}: Error on nonexistent dates.
}

\emph{Warning}: When used in arithmetic with date-times, \code{"last-day"} and
\code{"first-day"} do not guarantee that the relative ordering of \code{x} is
maintained.}

\item{dst_nonexistent}{\verb{[NULL / character]}

Control the behavior when a nonexistent time is generated due to a
daylight savings gap.
\itemize{
\item \code{NULL}:
If \code{n} is positive, choose \code{"roll-forward"}.
If \code{n} is negative, choose \code{"roll-backward"}.
\item \code{"roll-forward"}: Roll forward to the next valid moment in time.
\item \code{"roll-backward"}: Roll backward to the previous valid moment in time.
\item \code{"shift-forward"}: Shift the nonexistent time forward by the
length of the daylight savings gap (which is usually 1 hour).
\item \code{"shift-backward"}: Shift the nonexistent time backward
by the length of the daylight savings gap (which is usually 1 hour).
\item \code{"NA"}: Replace the nonexistent time with \code{NA}.
\item \code{error}: Error on nonexistent times.
}

\emph{Warning}: When used in arithmetic, \code{"shift-directional"},
\code{"shift-forward"}, and \code{"shift-backward"} do not guarantee that the
relative ordering of \code{x} is maintained.}

\item{dst_ambiguous}{\verb{[NULL / character]}

Control the behavior when an ambiguous time is generated due to a daylight
savings fallback.
\itemize{
\item \code{NULL}:
If \code{n} is positive, choose \code{"earliest"}.
If \code{n} is negative, choose \code{"latest"}.
\item \code{"earliest"}: Choose the earliest of the two possible ambiguous times.
\item \code{"latest"}: Choose the latest of the two possible ambiguous times.
\item \code{"NA"}: Replace the ambiguous time with \code{NA}.
\item \code{"error"}: Error on ambiguous times.
}}
}
\description{
Zoned arithmetic involves adding or subtracting units of time from a datetime
that has a time zone attached. This means that all of the complexities of
daylight savings time and nonexistent days have to be handled after each
individual arithmetic operation. The alternative is
\link[=clock-naive-arithmetic]{naive arithmetic}, which only deals with the
complexities of time zones once after all arithmetic has been performed.

Zoned arithmetic is usually fine for additions of singular units of time.
If you want to add multiple periods, consider switching to naive arithmetic.

The following add \emph{periods} of time. Periods are units of time that do
not have a fixed constant duration (i.e. a "month" may be 30 or 31 days).
\itemize{
\item \code{add_years()}
\item \code{add_months()}
\item \code{add_days()}
}

The following add \emph{durations} of time. Durations are fixed units of time
based on a set number of seconds.
\itemize{
\item \code{add_hours()}
\item \code{add_minutes()}
\item \code{add_seconds()}
}

When nonexistent or ambiguous date-times are landed on, the
\code{day_nonexistent}, \code{dst_nonexistent}, and \code{dst_ambiguous} options are
consulted to resolve any issues.
}
\examples{
x <- as.Date("2019-01-31")

add_days(x, 2)

# Adding one month theoretically lands us on
# "2019-02-31"
# but this doesn't exist, so `day_nonexistent`
# is consulted
add_months(x, 1)
add_months(x, 1, day_nonexistent = "first-time")

x <- as.POSIXct("1970-04-25 02:30:00", "America/New_York")
y <- as.POSIXct("1970-04-27 02:30:00", "America/New_York")

# Adding 1 day to `x` results in the nonexistent time of:
# "1970-04-26 02:30:00"
# at which point we have to make a decision about how to proceed using
# `dst_nonexistent`.
#
# Since we are adding a positive number of days, the default
# chooses `"roll-forward"` which rolls forward to the
# next valid moment in time.
add_days(x, 1)

# If we approach from the other side of the gap and subtract 1 day, then
# the default chooses `"roll-backward"`, which rolls backward
# to the previous valid moment in time.
subtract_days(y, 1)

# If you want to force one of these options,
# you can set `dst_nonexistent` directly
add_days(x, 1, dst_nonexistent = "roll-backward")
add_days(x, 1, dst_nonexistent = "NA")
}
