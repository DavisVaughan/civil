% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/arithmetic.R
\name{clock-naive-arithmetic}
\alias{clock-naive-arithmetic}
\alias{subtract_years.clock_naive_time_point}
\alias{subtract_years.clock_calendar}
\alias{subtract_quarters.clock_naive_time_point}
\alias{subtract_quarters.clock_calendar}
\alias{subtract_months.clock_naive_time_point}
\alias{subtract_months.clock_calendar}
\alias{subtract_weeks.clock_naive_time_point}
\alias{subtract_weeks.clock_calendar}
\alias{subtract_days.clock_naive_time_point}
\alias{subtract_days.clock_calendar}
\alias{add_hours.clock_naive_time_point}
\alias{add_hours.clock_calendar}
\alias{subtract_hours.clock_naive_time_point}
\alias{subtract_hours.clock_calendar}
\alias{add_minutes.clock_naive_time_point}
\alias{add_minutes.clock_calendar}
\alias{subtract_minutes.clock_naive_time_point}
\alias{subtract_minutes.clock_calendar}
\alias{add_seconds.clock_naive_time_point}
\alias{add_seconds.clock_calendar}
\alias{subtract_seconds.clock_naive_time_point}
\alias{subtract_seconds.clock_calendar}
\alias{add_milliseconds.clock_naive_time_point}
\alias{add_milliseconds.clock_calendar}
\alias{subtract_milliseconds.clock_naive_time_point}
\alias{subtract_milliseconds.clock_calendar}
\alias{add_microseconds.clock_naive_time_point}
\alias{add_microseconds.clock_calendar}
\alias{subtract_microseconds.clock_naive_time_point}
\alias{subtract_microseconds.clock_calendar}
\alias{add_nanoseconds.clock_naive_time_point}
\alias{add_nanoseconds.clock_calendar}
\alias{subtract_nanoseconds.clock_naive_time_point}
\alias{subtract_nanoseconds.clock_calendar}
\title{Naive date-time arithmetic}
\usage{
\method{subtract_years}{clock_naive_time_point}(x, n, ..., day_nonexistent = "last-time")

\method{subtract_years}{clock_calendar}(x, n, ..., day_nonexistent = "last-time")

\method{subtract_quarters}{clock_naive_time_point}(x, n, ..., day_nonexistent = "last-time")

\method{subtract_quarters}{clock_calendar}(x, n, ..., day_nonexistent = "last-time")

\method{subtract_months}{clock_naive_time_point}(x, n, ..., day_nonexistent = "last-time")

\method{subtract_months}{clock_calendar}(x, n, ..., day_nonexistent = "last-time")

\method{subtract_weeks}{clock_naive_time_point}(x, n, ...)

\method{subtract_weeks}{clock_calendar}(x, n, ...)

\method{subtract_days}{clock_naive_time_point}(x, n, ...)

\method{subtract_days}{clock_calendar}(x, n, ...)

\method{add_hours}{clock_naive_time_point}(x, n, ...)

\method{add_hours}{clock_calendar}(x, n, ...)

\method{subtract_hours}{clock_naive_time_point}(x, n, ...)

\method{subtract_hours}{clock_calendar}(x, n, ...)

\method{add_minutes}{clock_naive_time_point}(x, n, ...)

\method{add_minutes}{clock_calendar}(x, n, ...)

\method{subtract_minutes}{clock_naive_time_point}(x, n, ...)

\method{subtract_minutes}{clock_calendar}(x, n, ...)

\method{add_seconds}{clock_naive_time_point}(x, n, ...)

\method{add_seconds}{clock_calendar}(x, n, ...)

\method{subtract_seconds}{clock_naive_time_point}(x, n, ...)

\method{subtract_seconds}{clock_calendar}(x, n, ...)

\method{add_milliseconds}{clock_naive_time_point}(x, n, ...)

\method{add_milliseconds}{clock_calendar}(x, n, ...)

\method{subtract_milliseconds}{clock_naive_time_point}(x, n, ...)

\method{subtract_milliseconds}{clock_calendar}(x, n, ...)

\method{add_microseconds}{clock_naive_time_point}(x, n, ...)

\method{add_microseconds}{clock_calendar}(x, n, ...)

\method{subtract_microseconds}{clock_naive_time_point}(x, n, ...)

\method{subtract_microseconds}{clock_calendar}(x, n, ...)

\method{add_nanoseconds}{clock_naive_time_point}(x, n, ...)

\method{add_nanoseconds}{clock_calendar}(x, n, ...)

\method{subtract_nanoseconds}{clock_naive_time_point}(x, n, ...)

\method{subtract_nanoseconds}{clock_calendar}(x, n, ...)
}
\arguments{
\item{x}{\verb{[clock_naive]}

A naive date-time vector.}

\item{n}{\verb{[integer]}

An integer vector representing the number of units to add to or
subtract from \code{x}.}

\item{...}{These dots are for future extensions and must be empty.}

\item{day_nonexistent}{\verb{[character(1)]}

Control the behavior when a nonexistent day is generated.
\itemize{
\item \code{"last-time"}: Adjust to the last possible time of the current month.
\item \code{"first-time"}: Adjust to the first possible time of the following month.
\item \code{"last-day"}: Adjust to the last day of the current month. For
date-times, the sub-daily components are kept.
\item \code{"first-day"}: Adjust to the first day of the following month. For
date-times, the sub-daily components are kept.
\item \code{"NA"}: Replace the nonexistent date with \code{NA}.
\item \code{"error"}: Error on nonexistent dates.
}

\emph{Warning}: When used in arithmetic with date-times, \code{"last-day"} and
\code{"first-day"} do not guarantee that the relative ordering of \code{x} is
maintained.}
}
\description{
Naive arithmetic involves adding or subtracting units of time from a datetime
that is independent of any time zone. This means that daylight savings time
is never an issue while working with a naive datetime. Usually, you will
convert to a naive datetime with \code{\link[=as_naive_time_point]{as_naive_time_point()}}, perform multiple
arithmetic operations or adjustments with it, then convert it back to a
zoned datetime with \code{\link[=as_zoned_time_point]{as_zoned_time_point()}}.

Naive arithmetic is usually appropriate when performing multiple arithmetic
operations in a row (like adding a set of years, months, and days). The
alternative is \link[=clock-zoned-arithmetic]{zoned arithmetic}, which is simpler
and more straightforward when you just need to perform a single operation
(like just adding 3 months).
}
\section{Nonexistent Days}{

Naive datetimes are unique because they are allowed to land on \emph{nonexistent
days}. These might occur from adding 1 month to \code{"1971-01-29"}, which
theoretically lands on \code{"1971-02-29"}, a nonexistent day. With zoned
arithmetic, you are immediately forced to make a decision on how to handle
this nonexistent day. With naive arithmetic, that decision is delayed,
allowing you precise control over how to handle this case. As an example, you
might choose to add 1 year to this nonexistent date, resulting in
\code{"1972-02-29"}, which does exist due to it being a leap year. Or you might
convert it back to a zoned date with \code{\link[=as_zoned_time_point]{as_zoned_time_point()}}, which forces
you to deal with the nonexistent date using the \code{day_nonexistent} argument.
The default would choose the last real day in February of that year,
resulting in \code{"1971-02-28"}.

There are operations that force you to resolve nonexistent days. Using
\code{add_days()}, \code{add_hours()}, \code{add_minutes()}, or \code{add_seconds()} will
force you to resolve the nonexistent day by using the \code{day_nonexistent}
argument. After the nonexistent day has been resolved, the unit of time
is added.
}

